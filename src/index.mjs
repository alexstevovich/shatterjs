/********************************************************
 * shatterjs
 * 
 * ~ That which endures, neither made nor destroyed.
 *                              â€” Plato
 *  
 * @license
 * 
 * Apache-2.0
 * 
 * Copyright 2024-2025 Alex Stevovich
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * @meta
 *
 * package_name: shatterjs
 * file_name: src/index.mjs
 * purpose: Contains the core objects and full package functionality.
 *  
 * @system
 *
 * generated_on: 2025-03-06T23:23:29.414Z
 * certified_version: 1.0.0
 * file_uuid: 55823809-6965-4f3e-84da-b7d662a60c15
 * file_size: 7087 bytes
 * file_hash: 068ccfbc6d7dbc5369fcf06cce4569ab49db07317393cdd2a5fd59bf200befa4
 * mast_hash: d12ea87ecd6b699938900de79ebea8c8d158183b58201b50ba4e4639823747f6
 *  
 *             ~ generated by lawfulgood 
 *
********************************************************/
class Component {
    static get componentType() { return 'component'; }

    get componentType() {
        return this.constructor.componentType;
    }
}

class Partition extends Component {
    static get componentType() { return 'partition'; }

    constructor() {
        super();
        this._lines = [];
    }

    from(lines) {
        this._lines = lines;
        return this
    }

    exists() {
        return this.lines.length > 0;
    }

    get lines() {
        return this._lines;
    }

    get content() {
        return this.lines.join('\n');
    }
}

class EmptyLine extends Component {
    static get componentType() { return 'empty'; }

    constructor() {
        super();
    }

    get lines() {
        return [''];
    }
}

class InlineComment extends Component {
    static get componentType() { return 'inline_comment'; }

    constructor(line) {
        super();
        this.line = line;
    }

    get lines() {
        return [this.line];
    }
}

export class BlockComment extends Component {
    static get componentType() { return 'block_comment'; }

    constructor(lines) {
        super();
        this._lines = lines;
    }

    get lines() {
        return this._lines;
    }
}

class DecorativeSection extends Partition {
    static get componentType() { return 'decorative_partition'; }

    constructor() {
        super();
        this.elements = [];
    }

    from(lines) {
        this.elements = [];
        let i = 0;
        while (i < lines.length) {
            const line = lines[i].trim();

            if (line === '') {
                this.elements.push(new EmptyLine());
                i++;
            } else if (line.startsWith('//')) {
                this.elements.push(new InlineComment(lines[i]));
                i++;
            } else if (line.startsWith('/*')) {
                const blockLines = [lines[i]];
                i++;
                while (i < lines.length && !lines[i].includes('*/')) {
                    blockLines.push(lines[i]);
                    i++;
                }
                if (i < lines.length) blockLines.push(lines[i]); // capture closing */
                this.elements.push(new BlockComment(blockLines));
                i++;
            } else {
                break; // Stop at first non-decorative line
            }
        }

        return this;
    }

    get lines() {
        return this.elements.flatMap(element => element.lines);
    }

    get content() {
        return this.lines.join('\n');
    }

    exists() {
        return this.elements.length > 0;
    }
}

class Shebang extends Partition {
    static get componentType() { return 'shebang'; }
}

class Head extends DecorativeSection {
    static get componentType() { return 'head'; }
}

class Footer extends DecorativeSection {
    static get componentType() { return 'footer'; }
}

class Body extends Partition {
    static get componentType() { return 'body'; }
}

function extractShebang(lines) {
    if (lines[0]?.startsWith('#!')) {
        return [lines[0]];
    }
    return [];
}

function findIndexOfFirstLineOfCode(lines) {
    let inBlockComment = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (inBlockComment) {
            if (line.includes('*/')) inBlockComment = false;
            continue;
        }

        if (line === '') continue;
        if (line.startsWith('//')) continue;
        if (line.startsWith('/*')) {
            if (!line.includes('*/')) inBlockComment = true;
            continue;
        }

        return i;
    }

    return -1;
}

function findLastLineOfCode(lines) {
    let inBlockComment = false;

    for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();

        if (line === '') continue;
        if (line.startsWith('//')) continue;
        if (line.endsWith('*/')) {
            inBlockComment = true;
            continue;
        }
        if (inBlockComment) {
            if (line.startsWith('/*')) inBlockComment = false;
            continue;
        }

        return i;
    }

    return -1;
}

export class Doc extends Component {
    static get componentType() { return 'doc'; }

    constructor() {
        super();
        this.shebang = new Shebang();
        this.head = new Head();
        this.body = new Body();
        this.footer = new Footer();
    }

    from(content) {
        let lines = Array.isArray(content) ? content : content.split('\n');

        const shebangLines = extractShebang(lines);
        this.shebang.from(shebangLines);
        if (this.shebang.exists()) lines.shift();

        const codeStartAt = findIndexOfFirstLineOfCode(lines);

        if (codeStartAt === -1) {
            this.head.from(lines); // No code at all
            return;
        }

        const headLines = lines.slice(0, codeStartAt);
        this.head.from(headLines);

        const lastCodeLineIndex = findLastLineOfCode(lines);

        const bodyLines = lines.slice(codeStartAt, lastCodeLineIndex + 1);
        this.body.from(bodyLines);

        const footerLines = lines.slice(lastCodeLineIndex + 1);
        this.footer.from(footerLines);
    }

    get content() {
        return [
            this.shebang.content,
            ...this.head.lines,
            ...this.body.lines,
            ...this.footer.lines,
        ]
        .filter(Boolean)
        .join('\n');
    }
}